# -*- coding: utf-8 -*-
"""withoutCenter.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1dVQOv5HY5rgfuRHl-iqflfsNBpQgF1af
"""

import pandas as pd
import numpy as np
import io
from google.colab import files
uploaded=files.upload()

#do pca without data centering
import matplotlib.pyplot as plt
df=pd.read_csv('Dataset.csv',header=None)
df=df.to_numpy()
n=df.shape[0]
m=df.shape[1]

#calulate transpose and create the covariance matrix
def computeCov():
  data=np.zeros((m,m))
  #calculating the transpose matrix
  dft=np.zeros((2,1000))
  for i in range (m):
    for j in range(n):
      dft[i][j]=df[j][i]
  #calculate the product i.e data for the model
  for i in range(m):
    for j in range(m):
      for k in range(n):
        data[i][j]=data[i][j]+dft[i][k]*df[k][j]
  for i in range(m):
    for j in range(m):
      data[i][j]=data[i][j]/n
  return data

def plotOriginal():
  plt.scatter(df[:,0],df[:,1])
  plt.xlabel("Dimension 1")
  plt.ylabel("Dimension 2")
  plt.title("Original data")
  plt.axline((0,0),(-0.323516, -0.9462227),color = "red",label = 'w1')
  plt.axline((0,0),(-0.9462227, 0.323516),color = "black",label = 'w2')
  plt.legend(bbox_to_anchor = (1.05, 0.6))
  plt.show()

#calculate the eigen vector and eigen values
def computeEigen(data):
  w,v=np.linalg.eig(data)
  idx=w.argsort()[::-1]
  w=w[idx]
  v=v[:,idx]
  #we cant eliminate any direction so project along both directions
  projected=np.zeros((1000,2))
  for i in range(n):
    for j in range(m):
      for k in range(m):
        projected[i][j]=projected[i][j]+df[i][k]*v[k][j];
  print("Projections computed successfully")
  return projected

#project on dimensions
def project(projected):
  plt.scatter(projected[:,0],projected[:,1])
  plt.xlabel("Principal component 1(Largest Eigen Value)")
  plt.ylabel("Principal component 2(Second Largest Eigen Value)")
  plt.title("Plot for not centered data")
  plt.show()

def calVar(projected):
  #calculate the variance over principal components
  var_x=0
  var_y=0
  for i in range(n):
    var_x=var_x+projected[i][0]*projected[i][0]
    var_y=var_y+projected[i][1]*projected[i][1]
  var_x=var_x/1000
  var_y=var_y/1000
  total=var_x+var_y
  var_x=var_x/total
  var_x=var_x*100
  var_y=var_y/total
  var_y=var_y*100
  print("Variance along the first principal component",var_x,"%")
  print("Variance along the second principal component",var_y,"%")

data=computeCov()
projected=computeEigen(data)
plotOriginal()
project(projected)
calVar(projected)