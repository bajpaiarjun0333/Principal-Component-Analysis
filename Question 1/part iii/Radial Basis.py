# -*- coding: utf-8 -*-
"""radialBasis1.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1YFDXpYU10WUQDouDtIJz3jGgBZPmBmDS
"""

import pandas as pd
import numpy as np
from google.colab import files
uploaded=files.upload()

import matplotlib.pyplot as plt
df=pd.read_csv('Dataset.csv',header=None)
df=df.to_numpy()
n=df.shape[0]
m=df.shape[1]
k=np.zeros((n,n))

#create the transpose of data matrix
dft=np.zeros((n,n))
for i in range(m):
  for j in range(n):
    dft[i][j]=df[j][i]
#transpose calculated sucessfully

#calculating the kernel matrix
def kernelCompute(factor):
  k=np.zeros((n,n));
  for i in range(n):
    for j in range(n):
      diff=df[i,:]-df[j,:]
      val=np.matmul(diff,np.transpose(diff))
      val=val*-1
      val=val/(2*factor*factor)
      val=np.exp(val)
      k[i][j]=val
  return k

#adding the step to center the kernel matrix
def kernelCenter(k):
  I=np.zeros((n,n))
  for i in range(n):
    for j in range(n):
      if i==j:
        I[i][j]=1
  #identity matrix is ready 
  one=np.zeros((n,n))
  for i in range(n):
    for j in range(n):
      one[i][j]=1/n;
  diff=I-one
  #centering the kernel matrix
  res=np.matmul(diff,k)
  res2=np.matmul(res,diff)
  k=res2
  return k

def computeEigen(k):
  w,v=np.linalg.eig(k)
  idx=w.argsort()[::-1]
  w=w[idx]
  v=v[:,idx]
  w=w[0:2]
  v=v[:,0:2]
  #normalize the eigen vecotrs
  eigenValue1=w[0]
  eigenValue2=w[1]
  eigenVector1=v[:,0]
  eigenVector2=v[:,1]
  for i in range(n):
    eigenVector1[i]=eigenVector1[i]/np.sqrt(eigenValue1)
    eigenVector2[i]=eigenVector2[i]/np.sqrt(eigenValue2)
  return (eigenVector1,eigenVector2)

def project(k, eigenVector1, eigenVector2,r):
  dim1=np.matmul(np.transpose(k), eigenVector1)
  dim2=np.matmul(np.transpose(k), eigenVector2)
  plt.scatter(dim1,dim2)
  plt.xlabel("Principal component 1(Largest Eigen Value)")
  plt.ylabel("Principal component 2(Second Largest Eigen Value)")
  st="Plot for Radial Kernel"
  plt.title(st)
  plt.show()

def plotOriginal():
  plt.scatter(df[:,0],df[:,1])
  plt.xlabel("Dimension 1")
  plt.ylabel("Dimension 2")
  plt.title("Original data")
  plt.show()

factor=0.1
print("Printing Original Data")
plotOriginal()
while factor<=1:
  k=kernelCompute(factor)
  k=kernelCenter(k)
  (eigenVector1,eigenVector2)=computeEigen(k)
  print("Printing for r=", factor)
  project(k,eigenVector1,eigenVector2,factor)
  factor=factor+0.1