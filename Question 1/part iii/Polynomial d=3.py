# -*- coding: utf-8 -*-
"""polyd3.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/18TDnjgm3vyo0FCqVPIK4Fg0crkqxyAXX
"""

import pandas as pd
import numpy as np
from google.colab import files
uploaded=files.upload()

import matplotlib.pyplot as plt
df=pd.read_csv('Dataset.csv',header=None)
df=df.to_numpy()
n=df.shape[0]
m=df.shape[1]
k=np.zeros((n,n))

#create the transpose of data matrix
dft=np.zeros((n,n))
for i in range(m):
  for j in range(n):
    dft[i][j]=df[j][i]
#transpose calculated sucessfully

#calculating the kernel matrix
def computeKernel():
  k=np.zeros((n,n));
  for i in range(n):
    for j in range(n):
      val=0
      for o in range(m):
        val=val+df[i][o]*dft[o][j]
      val=val+1;
      val=val*val*val
      k[i][j]=val
  return k

#adding the step to center the kernel matrix
def kernelCenter(k):
  I=np.zeros((n,n))
  for i in range(n):
    for j in range(n):
      if i==j:
        I[i][j]=1
  #identity matrix is ready 
  one=np.zeros((n,n))
  for i in range(n):
    for j in range(n):
      one[i][j]=1/n;
  diff=I-one
  res=np.matmul(diff,k)
  res2=np.matmul(res,diff)
  k=res2
  return k

def computeEigen(k):
  w,v=np.linalg.eig(k)
  idx=w.argsort()[::-1]
  w=w[idx]
  v=v[:,idx]
  w=w[0:2]
  v=v[:,0:2]
  w=w[0:2]
  v=v[:,0:2]
  #normalize the eigen vecotrs
  eigenValue1=w[0]
  eigenValue2=w[1]
  print("The largest Eigen Value is : ",eigenValue1)
  print("The Second largest Eigen Value is : ",eigenValue2)
  eigenVector1=v[:,0]
  eigenVector2=v[:,1]
  for i in range(n):
    eigenVector1[i]=eigenVector1[i]/np.sqrt(eigenValue1)
    eigenVector2[i]=eigenVector2[i]/np.sqrt(eigenValue2)
  return (eigenVector1,eigenVector2)

#project on dimensions
def project(eigenVector1,eigenVector2,k):
  dim1=np.matmul(np.transpose(k), eigenVector1)
  dim2=np.matmul(np.transpose(k), eigenVector2)
  plt.scatter(dim1,dim2)
  plt.xlabel("Principal component 1(Largest Eigen Value)")
  plt.ylabel("Principal component 2(Second Largest Eigen Value)")
  plt.title("Plot for polynomial kernel d=3")
  plt.show()

def plotOriginal():
  plt.scatter(df[:,0],df[:,1])
  plt.xlabel("Dimension 1")
  plt.ylabel("Dimension 2")
  plt.title("Original data")
  plt.show()

k=computeKernel()
k=kernelCenter(k)
eigenVector1,eigenVector2=computeEigen(k)
plotOriginal()
project(eigenVector1,eigenVector2,k)