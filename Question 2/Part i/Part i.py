# -*- coding: utf-8 -*-
"""ques2Part1.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1CUM3fpCz6YABe2MjuvUE14gF1PeQVKni
"""

#importing all the libraries to be used 
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from google.colab import files
uploaded=files.upload()

#load the data file here 
df=pd.read_csv('Dataset.csv',header=None)
df=df.to_numpy()
n=df.shape[0]
m=df.shape[1]

#pick any k random data point and call them as cluster
import random
def randomCentroids(k):
  centroids=[]
  for i in range(k):
    index=random.randint(0,n)
    centroids.append(df[index,:])
  return centroids

def calculateDistance(x,y):
  #these x and y are supposed to be m dimensional vectors
  dist=0;
  for i in range(len(x)):
    diff=x[i]-y[i]
    diff=diff*diff
    dist=dist+diff
  return dist

#we need to assign for the first time data point to each cluster
def assign(centroids,k):
  z=[]
  for i in range(n):
    x=df[i,:]
    temp_dist=[]
    for j in range(k):
      y=centroids[j]
      dist=calculateDistance(x,y)
      temp_dist.append(dist)
    index=np.argmin(temp_dist)
    z.append(index)
  return z

def calculateMean(z,centroids,k):
  #we have to calulate mean for all 4 clusters i.e meu
  meu=[]
  for i in range(k):
    sum=[]
    num=0;
    for j in range(n):
      if z[j]==i:
        num=num+1
        sum.append(df[j,:])
    meu.append(np.mean(sum,axis=0))
  return meu
#this will return all the meu

#i have all the basic functionality now
def reassign(z,meu,k):
  #meu contains all the means of the clusters
  #check all points if they want to switch their means
  flag=False
  znew=[]
  for i in range(n):
    znew.append(z[i])
  for i in range(n):
    #for every point
    ownDist=calculateDistance(df[i,:],meu[z[i]])
    ownClus=z[i]
    for j in range(k):
      nextDist=calculateDistance(df[i,:],meu[j])
      if nextDist<ownDist:
        ownDist=nextDist
        ownClus=j
        flag=True
    znew[i]=ownClus
  return (flag,znew)

def computeErrors(meu,z):
  #we know the mean matrix and the point assignment, compute the error
  error=0
  for i in range(n):
    error=error+calculateDistance(df[i,:],meu[z[i]])
  return error

def paintVornoi(meu,colors,k):
  x=[]
  y=[]
  c=[]
  i=-11
  while(i<11):
    j=-11
    while(j<11):
      #paint this point i,j in diff color
      dist=[]
      for l in range(k):
        d=calculateDistance([i,j],meu[l])
        dist.append(d)
      index=np.argmin(dist)
      x.append(i)
      y.append(j)
      c.append(index)
      j=j+0.05
    i=i+0.05
    
  v=pd.DataFrame(list(zip(x,y,c)),columns=['X','Y','Z'])
  plt.scatter(v['X'][(v.Z==0)],v['Y'][v.Z==0],marker='o',color='r',label='Region1')
  plt.scatter(v['X'][(v.Z==1)],v['Y'][v.Z==1],marker='o',color='g',label='Region2')
  plt.scatter(v['X'][(v.Z==2)],v['Y'][v.Z==2],marker='o',color='b',label='Region3')
  plt.scatter(v['X'][(v.Z==3)],v['Y'][v.Z==3],marker='o',color='coral',label='Region4')
  plt.scatter(v['X'][(v.Z==4)],v['Y'][v.Z==4],marker='o',color='cyan',label='Region5')
  plt.legend(bbox_to_anchor=(1.05,0.6))

def plotOriginal():
  print("The Original Dataset")
  plt.scatter(df[:,0],df[:,1])
  plt.xlabel("Dimension 1")
  plt.ylabel("Dimension 2")
  plt.title("Original Data without Clustering")
  plt.show()

def llyod(k,num):
  print("Random Initialization :: The iteration is ",num)
  err=[]
  clusters=randomCentroids(k)
  z=assign(clusters,k)
  meu=calculateMean(z,clusters,k)
  e=0
  e=e+computeErrors(meu,z)
  err.append(e)
  r,znew=reassign(z,meu,k)
  z=np.copy(znew)
  #print(z)
  meu=calculateMean(z,clusters,k)
  e=0
  e=e+computeErrors(meu,z)
  err.append(e)
  count=0
  while r:
    r,znew=reassign(z,meu,k)
    z=np.copy(znew)
    meu=calculateMean(z,clusters,k)
    e=0
    e=e+computeErrors(meu,z)
    err.append(e)
    count=count+1
  print("Steps to converge :: ", count)
  #print the clusters
  colors={0:'r',1:'g',2:'b',3:'coral',4:'cyan'}
  for i in range(n):
    plt.scatter(df[i][0],df[i][1],color=colors[z[i]])
  plt.xlabel("Dimension 1")
  plt.ylabel("Dimension 2")
  plt.title("After K Means Clustering Iteration "+str(num))
  plt.show()
  #vornoi regions
  for i in range(k):
    plt.scatter(meu[i][0],meu[i][1],color=colors[z[i]],marker='v')
  paintVornoi(meu,colors,k)
  plt.show()
  #plot the errors over the iterations 
  for i in range(count+2):
    plt.scatter(i, err[i])
  plt.xlabel("Iteration Number")
  plt.ylabel("Error")
  plt.title("Error Plot")
  plt.show()

plotOriginal()

for i in range(5):
  llyod(4,i)